import sqlite3
from telegram import Update
from telegram.ext import ApplicationBuilder, ContextTypes, MessageHandler, filters
from telethon import TelegramClient
from random import randint
import asyncio
from time import sleep
import datetime
import json

channels_list = ["novosti_voinaa"] 
                #  "truexanewsua", 
                #  "rian_ru", 
                #  "readovkanews", 
                #  "bbbreaking", 
                #  "ostorozhno_novosti", 
                #  "voynareal", 
                #  "wargonzo", 
                #  "nexta_live", 
                #  "meduzalive", 
                #  "pravdadirty", 
                #  "varlamov_news"]

with open("credentials.json" , 'r') as cr:
    data = json.load(cr)
    api_id = data["api_id"]
    api_hash = data["api_hash"]
parser = TelegramClient('anon', api_id, api_hash).start()
# bot_token = "5909054565:AAHilbEQT8IozDDmn7b4i_GkN4XE2FxHTrQ"

con = sqlite3.connect("dataset.sql")
cur = con.cursor()

cur.execute("DROP TABLE IF EXISTS posts")
cur.execute("CREATE TABLE posts(id INTEGER PRIMARY KEY AUTOINCREMENT, channel VARCHAR(16), text VARCHAR(4096))")
res = cur.execute("SELECT * FROM posts")
for row in res.fetchall():
    print(str(row))


async def get_channel_messages(channel, amount, start_id):
    res = []
    # if start_id < 0:
    #     print("-1")
    #     async for msg in parser.iter_messages(channel, limit = 1): #getting last message from channel
    #         print("start_id acqired")
    #         start_id = msg.id
    async for msg in parser.iter_messages(channel, limit = amount): # max_id = start_id
        try: 
            print("Message received from" + channel)
            if len(msg.raw_text) > 64: 
                res.append(({"channel": channel, "text": msg.raw_text}))
        except Exception as e:
            print("An error occurred: " + str(e))
    # if len(res) < amount:
    #     add = get_channel_messages(channel, amount - len(res), start_id = start_id - amount)
    #     print("sent again")
    #     res += add
    return res

asyncio.run(get_channel_messages('bbcrussian', 100, 1))

# for ch in channels_list:
#     print(ch)
#     posts = asyncio.run(get_channel_messages(ch, 100, -1))
#     cur.executemany("INSERT INTO posts (channel, text) VALUES (:channel, :text)", posts)
#     con.commit()
#     for row in cur.execute("SELECT * FROM posts").fetchall():
#         print(row)
#     sleep(randint(1, 10))


# async def save_post(update: Update, context: ContextTypes.DEFAULT_TYPE):
#     try:
#         print("Message received")
#         channel = update.message.forward_from_chat.username
#         text = ""
#         try:
#             text = update.message.text.replace("\n", "")  
#         except:
#             text = update.message.caption.replace("\n", "")  
        
#         time = str(update.message.date.year) + '-' + str(update.message.date.month) + '-' + str(update.message.date.day) + '-' + str(update.message.date.hour) + '-' + str(update.message.date.minute) + '-' + str(update.message.date.second)
#         # print("Date: " + time)
#         data = {"text": text}
#         res = cur.execute("SELECT * FROM posts WHERE text = :text", data)
#         if res.fetchmany() == [] and len(text) >= 100:
#             data = {"channel": channel, "text": text, "time" : time}
#             cur.execute("INSERT INTO posts (channel, text, time) VALUES (:channel, :text, :time)", data)
#             con.commit()

#             data = {"text": text}
#             res = cur.execute("SELECT * FROM posts WHERE text = :text", data)
#             print(res.fetchmany())

#         # res = cur.execute("SELECT * FROM posts")
#         # print(res.fetchall())
#         con.commit()

#     except Exception as e:
#         print("An error occurred: " + str(e))


# if __name__ == "__main__":
#     application = ApplicationBuilder().token(bot_token).build()
#     application.add_handler(MessageHandler(filters.ALL, save_post))
#     application.run_polling()